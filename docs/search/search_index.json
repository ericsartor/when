{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the When docs! When is a keyboard shortcut library with a focus on developer experience and readability. It aims to provide the features you need to have complete control over your user's keyboard experience, with an easy to use API! Go check out the overview to see what When is all about, or jump right into installation if you're ready to get started!","title":"Home"},{"location":"installation/","text":"Installation","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"overview/","text":"Overview When is a chainable library for creating simple or intricate keyboard shortcuts in your web apps. A basic example might look something like this: When('copy').IsExecuted().Run((context) => { // your logic here... }); When('ctrl+c').IsPressed().Execute('copy'); whereas a more advanced example would look something like this: When('a') .IsPressed() .Then('num1') .IsHeldFor(1) .Seconds() .Then('a') .IsReleased() .Execute((context) => { // your logic here }, 'a1_command') .Once(); You can also specify key sequences like this (as long as you only plan on using pressed events): // when the keys a, s and d are pressed consecutively within 1 second When('a s d (1s)').IsInput().Execute((context) => console.log('asd')); Feature Summary When supports many features all aimed at making managing your keyboard shortcuts easier, such as: events event context registered commands shortcut controllers sequences qualifiers modes groups focus self-documentation Events When is triggered by keyup and keydown events bound to the window key, but exposes three event types for consumption through it's API: pressed , released and held . These can be combined in any way you desire! // triggers as soon as the keydown event fires When('a').IsPressed().Execute(console.log); // triggers as soon as the keyup event fires When('a').IsReleased().Execute(console.log); // triggers 1 second after the keydown event fired if the keyup event has not yet fired When('a').IsHeldFor(1).Seconds().Execute(console.log); Event Context Event handlers and registered commands receive an event context object as their only argument, which contains some useful properties: When('some_command').IsExecuted().Run((context) => { // context.event - the native browser event that caused the shortcut to be fulfilled (depending on what the last event is in the shortcut's sequence) // context.shortcut - the shortcut controller for the shortcut that was triggered // context.focusedElement - the HTMLElement that When currently considers to be focused based on its built in focus system // context.pressDuration - on \"held\" events, the duration in milliseconds the key was held for (if the last event in the shortcut's sequence was a \"held\" event) console.log(context); }); Registered Commands Commands are When's way of allowing you to separate your business logic from your shortcut logic, and aids in the self-documentation process. When('some_command').IsExecuted().Run((context) => { // some logic here... }); When('a').IsPressed().Execute('some_command'); Shortcut Controllers When you create a shortcut, it returns a controller with a few methods attached to it: const shortcut = When('a').IsPressed().Execute(console.log); shortcut.pause(); shortcut.unpause(); shortcut.toggle(); shortcut.trigger(); shortcut.destroy(); These are the primitive ways you can control how and when your shortcut can be triggered programmatically. Sequences Instead of specifying a shortcut as a single key (with optional modifier key), you can specify a sequence of keys in multiple ways. // these create the exact same shortcut When('1').IsPressed().Then('2').IsPressed().Then('3').IsPressed().Within(1).Seconds().Execute(console.log); When('1 2 3 (1s)').IsInput().Execute(console.log); Qualifiers Qualifiers give you access to some of the features native DOM events provide in a more readable way. When('ctrl+s') .IsPressed() .Execute('save') .AllowDefault() // event.preventDefault() is called by default, so this qualifier allows default browser behaviour, in this case, opening a Save prompt .Once() // the shortcut is destroyed after the first time it triggers .InInput(); // allows the shortcut to trigger while the document.activeElement is an input element (input/textarea/select) Modes Modes are a way of only allowing a certain subset of shortcuts to be active at any given time. Shortcuts that have not been assigned a mode will always be active by default. // will be active by default When('a').IsPressed().Execute(console.log); // won't be active until the mode is set to \"mode1\" When().ModeIs('mode1').Then('b').IsPressed().Execute(console.log); When.setMode('mode1'); Groups Groups are another way of controlling multiple shortcuts at a time by creating a single controller for them. They have all the same controller methods that a shortcut controller would have. const group1 = When.newGroup([ When('a').IsPressed().Execute(console.log), When('b').IsPressed().Execute(console.log), When('c').IsPressed().Execute(console.log), ]); const shortcut1 = When('d').IsPressed().Execute(console.log); const shortcut2 = When('e').IsPressed().Execute(console.log); const group2 = When.newGroup([shortcut1, shortcut2]); group1.pause(); group1.unpause(); group1.toggle(); group1.trigger(); group1.destroy(); Focus When includes a focus system, similar to the concept of focus found in operating systems. It allows you to limit shortcuts to only trigger when a certain element (or child) has been clicked on. <div id=\"some-id\" class=\"when-focus\"></div> <div class=\"some-class\"></div> <div class=\"some-class\"></div> const box = document.getElementById('box'); // these shortcut will only trigger when #some-id or one of its children were the last element to have been clicked. // they will cease to trigger when a sibling, parent or unrelated element has been clicked. When(box).IsFocused().Then('a').IsPressed().Execute(console.log); When('id:some-id').IsFocused().Then('b').IsPressed().Execute(console.log); // this will only trigger if any elemental with class \"some-class\" is focused When('class:some-class').IsFocused().Then('c').IsPressed().Execute(console.log); You can also tie into this system to make the current focus apparent to the user: When.focusChanges((newFocusEl, prevFocusEl) => { if (newFocusEl) { newFocusEl.classList.add('focused'); } if (prevFocusEl) { prevFocusEl.classList.remove('focused'); } }); Self Documentation When is capable of generating documentation for all the keyboard shortcuts you've registered up the to point that you call When.documentation() . It returns an array of { combination: string, command: string, mode: string } representing each shortcut. NOTE : This is primarily meant to be used a developer tool. Because only the shortcuts registered so far get documented, this will not necessarily document all of the shortcuts your app registers in its lifetime. Only display this information to your users if you are certain all shortcuts have been registered for the lifetime of the app. The shortcuts output by When.documentation() are deduplicated from the shortcuts created over the lifetime of the app so far, and are unique based on mode , combination and focusTarget . console.log(When.documentation()); /* [ { combination: '\u2193a', command: 'some_command', mode: '', } ] */","title":"Overview"},{"location":"overview/#overview","text":"When is a chainable library for creating simple or intricate keyboard shortcuts in your web apps. A basic example might look something like this: When('copy').IsExecuted().Run((context) => { // your logic here... }); When('ctrl+c').IsPressed().Execute('copy'); whereas a more advanced example would look something like this: When('a') .IsPressed() .Then('num1') .IsHeldFor(1) .Seconds() .Then('a') .IsReleased() .Execute((context) => { // your logic here }, 'a1_command') .Once(); You can also specify key sequences like this (as long as you only plan on using pressed events): // when the keys a, s and d are pressed consecutively within 1 second When('a s d (1s)').IsInput().Execute((context) => console.log('asd'));","title":"Overview"},{"location":"overview/#feature-summary","text":"When supports many features all aimed at making managing your keyboard shortcuts easier, such as: events event context registered commands shortcut controllers sequences qualifiers modes groups focus self-documentation","title":"Feature Summary"},{"location":"overview/#events","text":"When is triggered by keyup and keydown events bound to the window key, but exposes three event types for consumption through it's API: pressed , released and held . These can be combined in any way you desire! // triggers as soon as the keydown event fires When('a').IsPressed().Execute(console.log); // triggers as soon as the keyup event fires When('a').IsReleased().Execute(console.log); // triggers 1 second after the keydown event fired if the keyup event has not yet fired When('a').IsHeldFor(1).Seconds().Execute(console.log);","title":"Events"},{"location":"overview/#event-context","text":"Event handlers and registered commands receive an event context object as their only argument, which contains some useful properties: When('some_command').IsExecuted().Run((context) => { // context.event - the native browser event that caused the shortcut to be fulfilled (depending on what the last event is in the shortcut's sequence) // context.shortcut - the shortcut controller for the shortcut that was triggered // context.focusedElement - the HTMLElement that When currently considers to be focused based on its built in focus system // context.pressDuration - on \"held\" events, the duration in milliseconds the key was held for (if the last event in the shortcut's sequence was a \"held\" event) console.log(context); });","title":"Event Context"},{"location":"overview/#registered-commands","text":"Commands are When's way of allowing you to separate your business logic from your shortcut logic, and aids in the self-documentation process. When('some_command').IsExecuted().Run((context) => { // some logic here... }); When('a').IsPressed().Execute('some_command');","title":"Registered Commands"},{"location":"overview/#shortcut-controllers","text":"When you create a shortcut, it returns a controller with a few methods attached to it: const shortcut = When('a').IsPressed().Execute(console.log); shortcut.pause(); shortcut.unpause(); shortcut.toggle(); shortcut.trigger(); shortcut.destroy(); These are the primitive ways you can control how and when your shortcut can be triggered programmatically.","title":"Shortcut Controllers"},{"location":"overview/#sequences","text":"Instead of specifying a shortcut as a single key (with optional modifier key), you can specify a sequence of keys in multiple ways. // these create the exact same shortcut When('1').IsPressed().Then('2').IsPressed().Then('3').IsPressed().Within(1).Seconds().Execute(console.log); When('1 2 3 (1s)').IsInput().Execute(console.log);","title":"Sequences"},{"location":"overview/#qualifiers","text":"Qualifiers give you access to some of the features native DOM events provide in a more readable way. When('ctrl+s') .IsPressed() .Execute('save') .AllowDefault() // event.preventDefault() is called by default, so this qualifier allows default browser behaviour, in this case, opening a Save prompt .Once() // the shortcut is destroyed after the first time it triggers .InInput(); // allows the shortcut to trigger while the document.activeElement is an input element (input/textarea/select)","title":"Qualifiers"},{"location":"overview/#modes","text":"Modes are a way of only allowing a certain subset of shortcuts to be active at any given time. Shortcuts that have not been assigned a mode will always be active by default. // will be active by default When('a').IsPressed().Execute(console.log); // won't be active until the mode is set to \"mode1\" When().ModeIs('mode1').Then('b').IsPressed().Execute(console.log); When.setMode('mode1');","title":"Modes"},{"location":"overview/#groups","text":"Groups are another way of controlling multiple shortcuts at a time by creating a single controller for them. They have all the same controller methods that a shortcut controller would have. const group1 = When.newGroup([ When('a').IsPressed().Execute(console.log), When('b').IsPressed().Execute(console.log), When('c').IsPressed().Execute(console.log), ]); const shortcut1 = When('d').IsPressed().Execute(console.log); const shortcut2 = When('e').IsPressed().Execute(console.log); const group2 = When.newGroup([shortcut1, shortcut2]); group1.pause(); group1.unpause(); group1.toggle(); group1.trigger(); group1.destroy();","title":"Groups"},{"location":"overview/#focus","text":"When includes a focus system, similar to the concept of focus found in operating systems. It allows you to limit shortcuts to only trigger when a certain element (or child) has been clicked on. <div id=\"some-id\" class=\"when-focus\"></div> <div class=\"some-class\"></div> <div class=\"some-class\"></div> const box = document.getElementById('box'); // these shortcut will only trigger when #some-id or one of its children were the last element to have been clicked. // they will cease to trigger when a sibling, parent or unrelated element has been clicked. When(box).IsFocused().Then('a').IsPressed().Execute(console.log); When('id:some-id').IsFocused().Then('b').IsPressed().Execute(console.log); // this will only trigger if any elemental with class \"some-class\" is focused When('class:some-class').IsFocused().Then('c').IsPressed().Execute(console.log); You can also tie into this system to make the current focus apparent to the user: When.focusChanges((newFocusEl, prevFocusEl) => { if (newFocusEl) { newFocusEl.classList.add('focused'); } if (prevFocusEl) { prevFocusEl.classList.remove('focused'); } });","title":"Focus"},{"location":"overview/#self-documentation","text":"When is capable of generating documentation for all the keyboard shortcuts you've registered up the to point that you call When.documentation() . It returns an array of { combination: string, command: string, mode: string } representing each shortcut. NOTE : This is primarily meant to be used a developer tool. Because only the shortcuts registered so far get documented, this will not necessarily document all of the shortcuts your app registers in its lifetime. Only display this information to your users if you are certain all shortcuts have been registered for the lifetime of the app. The shortcuts output by When.documentation() are deduplicated from the shortcuts created over the lifetime of the app so far, and are unique based on mode , combination and focusTarget . console.log(When.documentation()); /* [ { combination: '\u2193a', command: 'some_command', mode: '', } ] */","title":"Self Documentation"},{"location":"features/events/","text":"Events When exposes three types of keyboard events built on top of the DOM keyup and keydown events: pressed , released and held , which are primarily registered using the IsPressed() , IsReleased() and IsHeldFor() methods, in addition to IsInput() , which is a compound way of registering pressed events. pressed The pressed event is synonymous with the native DOM keydown event. Each time a keydown event is fired for a given key, a pressed event is also fired for that key. Using this When event will achieve similar results as using the native keypress event, which is fired when a key that produces a character value is pressed down (though this is depreciated ). Anywhere you would use keydown or keypress , pressed will work. You can hook into the pressed event in the following ways: IsPressed() // here we are explicitly setting up a \"pressed\" handler for a single press of the \"a\" key When('a').IsPressed().Execute(console.log); IsInput() // here we are setting up a handler that responds to the keys \"a\", \"b\" and \"c\" being pressed in sequence. // using IsInput() allows you to enter sequences of characters into When() and Then(), and assumes you want \"pressed\" events for each When('a b c').IsInput().Execute(console.log); released The released event is synonymous with the native DOM keyup event. Each time a keyup event is fired for a given key, a released event is also fired for that key. The released event can only be registered using the standard chained method: // here we are explicitly setting up a \"released\" handler for a single release of the \"a\" key When('a').IsReleased().Execute(console.log); held The held event is When's own construct. It operates by having an interval running in the background that checks to see if a key is still pressed down. When it detects that a key has been pressed for longer than 500ms, a held event is registered. Each subsequent time that the same key is still held down, the event's duration property is simply updated to reflect the new duration. A held event is registered using multiple chain methods: When('a').IsHeldFor(1).Seconds().Execute(console.log); When('b').IsHeldFor(500).Milliseconds().Execute(console.log); Putting It All Together All these event types and registration methods can be used together in any way you see fit: When('a') .IsPressed() .Then('b') .IsHeldFor(1).Seconds() .Then('a') .IsReleased() .Then('num1 num2 num3') .IsInput() .Execute(console.log);","title":"Events"},{"location":"features/events/#events","text":"When exposes three types of keyboard events built on top of the DOM keyup and keydown events: pressed , released and held , which are primarily registered using the IsPressed() , IsReleased() and IsHeldFor() methods, in addition to IsInput() , which is a compound way of registering pressed events.","title":"Events"},{"location":"features/events/#pressed","text":"The pressed event is synonymous with the native DOM keydown event. Each time a keydown event is fired for a given key, a pressed event is also fired for that key. Using this When event will achieve similar results as using the native keypress event, which is fired when a key that produces a character value is pressed down (though this is depreciated ). Anywhere you would use keydown or keypress , pressed will work. You can hook into the pressed event in the following ways: IsPressed() // here we are explicitly setting up a \"pressed\" handler for a single press of the \"a\" key When('a').IsPressed().Execute(console.log); IsInput() // here we are setting up a handler that responds to the keys \"a\", \"b\" and \"c\" being pressed in sequence. // using IsInput() allows you to enter sequences of characters into When() and Then(), and assumes you want \"pressed\" events for each When('a b c').IsInput().Execute(console.log);","title":"pressed"},{"location":"features/events/#released","text":"The released event is synonymous with the native DOM keyup event. Each time a keyup event is fired for a given key, a released event is also fired for that key. The released event can only be registered using the standard chained method: // here we are explicitly setting up a \"released\" handler for a single release of the \"a\" key When('a').IsReleased().Execute(console.log);","title":"released"},{"location":"features/events/#held","text":"The held event is When's own construct. It operates by having an interval running in the background that checks to see if a key is still pressed down. When it detects that a key has been pressed for longer than 500ms, a held event is registered. Each subsequent time that the same key is still held down, the event's duration property is simply updated to reflect the new duration. A held event is registered using multiple chain methods: When('a').IsHeldFor(1).Seconds().Execute(console.log); When('b').IsHeldFor(500).Milliseconds().Execute(console.log);","title":"held"},{"location":"features/events/#putting-it-all-together","text":"All these event types and registration methods can be used together in any way you see fit: When('a') .IsPressed() .Then('b') .IsHeldFor(1).Seconds() .Then('a') .IsReleased() .Then('num1 num2 num3') .IsInput() .Execute(console.log);","title":"Putting It All Together"},{"location":"features/focus/","text":"Focus Overview Focus Constraints Element id class Reacting To Focus Changes Overview The focus system in When allows you to simulate the same experience of window/app focus that users get on their operating systems. This means that when a user clicks on part of the page, you can control what When considers to be in \"focus\". It's achieved using the special CSS when-focus class. Simply attach that class to any element you want to enable the focus feature on. When an element with the when-focus class name is clicked, or when one of its children are clicked, When considers that element to be in focus. Generally, you would use this on the parts of your app that are clearly distinct, such as on pop-up type components, sections of your page that are visually separate from each other, or window/overlay elements. Until an element (or child of) with the when-focus class is clicked, the focus is considered to be null . If an element is ever clicked that doesn't have the when-focus class and none of it's ancestors have it, the focus is reset to null . When the focus is null , no shortcut with a focus constraint will work. This feature can be very powerful, but is made even more robust by When exposing a way to tie into the focus system itself. With this, your app can react to the focus changing. You might use this to change your styles slightly when an element gains or loses focus, such as by altering opacity or adding a border or background color. Focus Constraints Element One way to specify a focus constraint on a shortcut to is pass a reference to the element itself to When() . <div class=\"when-focus\"> Content... </div> const div = document.getElementsByTagName('div')[0]; When(div).IsFocused().Then('a').IsPressed().Execute((context) => { const content = context.focusedElement.textContent; console.log(content); }); id Another way to add a focus constraint is with the id: selector. Note that the target element doesn't have to exist at the time the shortcut is created, but When will log a warning in that case. It will also log a warning if the element exists but the when-focus class is not present on it. <div id=\"test\" class=\"when-focus\"> Content... </div> When('id:test').IsFocused().Then('a').IsPressed().Execute((context) => { const content = context.focusedElement.textContent; console.log(content); }); class Finally, you can use the class: selector to select multiple elements. Again, the elements need not exist at the moment you create the shortcut, but When will log a warning if any of the elements that do exist are missing the when-focus class. <div class=\"card when-focus\"> <p>Card 1 content...<p/> </div> <div class=\"card when-focus\"> <p>Card 2 content...<p/> </div> <div class=\"card when-focus\"> <p>Card 3 content...<p/> </div> When('class:card').IsFocused().Then('a').IsPressed().Execute((context) => { const content = context.focusedElement.getElementsByTagName('p')[0].textContent; console.log(content); }); Reacting To Focus Changes A focus system is only really useful when the user understands which part of the page is in focus. To facilitate this, When exposes the When.focusChanges() utility for registering focus change handlers. You can register multiple handlers if required, but generally only one will be necessary. A modified version of the class: selector example can be seen below utilizing When.focusChanges() . .card { opacity: 0.5; } .focused { opacity: 1; } <div class=\"card when-focus\"> <p>Card 1 content...<p/> </div> <div class=\"card when-focus\"> <p>Card 2 content...<p/> </div> <div class=\"card when-focus\"> <p>Card 3 content...<p/> </div> When('class:card').IsFocused().Then('a').IsPressed().Execute((context) => { const content = context.focusedElement.getElementsByTagName('p')[0].textContent; console.log(content); }); When.focusChanges((newFocusElement, prevFocusElement) => { if (newFocusElement) { newFocusElement.classList.add('focused'); } if (prevFocusElement) { prevFocusedElement.classList.remove('focused'); } });","title":"Focus"},{"location":"features/focus/#focus","text":"Overview Focus Constraints Element id class Reacting To Focus Changes","title":"Focus"},{"location":"features/focus/#overview","text":"The focus system in When allows you to simulate the same experience of window/app focus that users get on their operating systems. This means that when a user clicks on part of the page, you can control what When considers to be in \"focus\". It's achieved using the special CSS when-focus class. Simply attach that class to any element you want to enable the focus feature on. When an element with the when-focus class name is clicked, or when one of its children are clicked, When considers that element to be in focus. Generally, you would use this on the parts of your app that are clearly distinct, such as on pop-up type components, sections of your page that are visually separate from each other, or window/overlay elements. Until an element (or child of) with the when-focus class is clicked, the focus is considered to be null . If an element is ever clicked that doesn't have the when-focus class and none of it's ancestors have it, the focus is reset to null . When the focus is null , no shortcut with a focus constraint will work. This feature can be very powerful, but is made even more robust by When exposing a way to tie into the focus system itself. With this, your app can react to the focus changing. You might use this to change your styles slightly when an element gains or loses focus, such as by altering opacity or adding a border or background color.","title":"Overview"},{"location":"features/focus/#focus-constraints","text":"","title":"Focus Constraints"},{"location":"features/focus/#element","text":"One way to specify a focus constraint on a shortcut to is pass a reference to the element itself to When() . <div class=\"when-focus\"> Content... </div> const div = document.getElementsByTagName('div')[0]; When(div).IsFocused().Then('a').IsPressed().Execute((context) => { const content = context.focusedElement.textContent; console.log(content); });","title":"Element"},{"location":"features/focus/#id","text":"Another way to add a focus constraint is with the id: selector. Note that the target element doesn't have to exist at the time the shortcut is created, but When will log a warning in that case. It will also log a warning if the element exists but the when-focus class is not present on it. <div id=\"test\" class=\"when-focus\"> Content... </div> When('id:test').IsFocused().Then('a').IsPressed().Execute((context) => { const content = context.focusedElement.textContent; console.log(content); });","title":"id"},{"location":"features/focus/#class","text":"Finally, you can use the class: selector to select multiple elements. Again, the elements need not exist at the moment you create the shortcut, but When will log a warning if any of the elements that do exist are missing the when-focus class. <div class=\"card when-focus\"> <p>Card 1 content...<p/> </div> <div class=\"card when-focus\"> <p>Card 2 content...<p/> </div> <div class=\"card when-focus\"> <p>Card 3 content...<p/> </div> When('class:card').IsFocused().Then('a').IsPressed().Execute((context) => { const content = context.focusedElement.getElementsByTagName('p')[0].textContent; console.log(content); });","title":"class"},{"location":"features/focus/#reacting-to-focus-changes","text":"A focus system is only really useful when the user understands which part of the page is in focus. To facilitate this, When exposes the When.focusChanges() utility for registering focus change handlers. You can register multiple handlers if required, but generally only one will be necessary. A modified version of the class: selector example can be seen below utilizing When.focusChanges() . .card { opacity: 0.5; } .focused { opacity: 1; } <div class=\"card when-focus\"> <p>Card 1 content...<p/> </div> <div class=\"card when-focus\"> <p>Card 2 content...<p/> </div> <div class=\"card when-focus\"> <p>Card 3 content...<p/> </div> When('class:card').IsFocused().Then('a').IsPressed().Execute((context) => { const content = context.focusedElement.getElementsByTagName('p')[0].textContent; console.log(content); }); When.focusChanges((newFocusElement, prevFocusElement) => { if (newFocusElement) { newFocusElement.classList.add('focused'); } if (prevFocusElement) { prevFocusedElement.classList.remove('focused'); } });","title":"Reacting To Focus Changes"},{"location":"features/groups/","text":"Groups Groups enable you to control groups of shortcuts as one. When you create a shortcut with When() , you get back a ShortcutController for that shortcut that allows you to do things like toggle() , trigger() or delete() that shortcut. With groups , you can create ShortcutController that control multiple shortcuts at once: const group = When.newGroup([ When('a').IsPressed().Execute(console.log), When('b').IsPressed().Execute(console.log), When('c').IsPressed().Execute(console.log), ]); // turns all the shortcuts in the group off group.pause(); These group controllers have all the same features as ShortcutController , and are simply an easier way of executing these controller methods on multiple shortcuts at a time. You can still access each shortcut's controllers if you save a reference to them before creating the group, but this is rarely a wise thing to do: const shortcutA = When('a').IsPressed().Execute(console.log); // active by default const shortcutB = When('b').IsPressed().Execute(console.log); // active by default const shortcutC = When('c').IsPressed().Execute(console.log); // active by default shortcutB.toggle(); // shortcutB is now inactive const group = When.newGroup([ shortcutA, shortcutB, shortcutC, ]); group.toggle(); // shortcutA and shortcutC are now inactive, // but shortcutB is active because it was already toggled separately In this case, the shortcuts will become out of sync with each other, and it could lead to unexpected results. Take care when using this approach.","title":"Groups"},{"location":"features/groups/#groups","text":"Groups enable you to control groups of shortcuts as one. When you create a shortcut with When() , you get back a ShortcutController for that shortcut that allows you to do things like toggle() , trigger() or delete() that shortcut. With groups , you can create ShortcutController that control multiple shortcuts at once: const group = When.newGroup([ When('a').IsPressed().Execute(console.log), When('b').IsPressed().Execute(console.log), When('c').IsPressed().Execute(console.log), ]); // turns all the shortcuts in the group off group.pause(); These group controllers have all the same features as ShortcutController , and are simply an easier way of executing these controller methods on multiple shortcuts at a time. You can still access each shortcut's controllers if you save a reference to them before creating the group, but this is rarely a wise thing to do: const shortcutA = When('a').IsPressed().Execute(console.log); // active by default const shortcutB = When('b').IsPressed().Execute(console.log); // active by default const shortcutC = When('c').IsPressed().Execute(console.log); // active by default shortcutB.toggle(); // shortcutB is now inactive const group = When.newGroup([ shortcutA, shortcutB, shortcutC, ]); group.toggle(); // shortcutA and shortcutC are now inactive, // but shortcutB is active because it was already toggled separately In this case, the shortcuts will become out of sync with each other, and it could lead to unexpected results. Take care when using this approach.","title":"Groups"},{"location":"features/modes/","text":"Modes Modes are one of the ways When allows you to enable or disable groups of shortcuts. Shortcuts can be assigned a mode and will only be active if that mode is active. Creating a shortcut with a mode : When().ModeIs('mode1').Then('a').IsPressed().Execute(console.log); When's mode is null by default, so you must change it using When.setMode() in order for the shortcut to be active: When.setMode('mode1'); The mode can be changed at any time, and even dynamically determined if necessary. And that's it! Modes are fairly simple, but can be an effect way of controlling your shortcut's scope.","title":"Modes"},{"location":"features/modes/#modes","text":"Modes are one of the ways When allows you to enable or disable groups of shortcuts. Shortcuts can be assigned a mode and will only be active if that mode is active. Creating a shortcut with a mode : When().ModeIs('mode1').Then('a').IsPressed().Execute(console.log); When's mode is null by default, so you must change it using When.setMode() in order for the shortcut to be active: When.setMode('mode1'); The mode can be changed at any time, and even dynamically determined if necessary. And that's it! Modes are fairly simple, but can be an effect way of controlling your shortcut's scope.","title":"Modes"},{"location":"features/shortcuts/","text":"Shortcuts When is a keyboard shortcut library, and it goes to many lengths to ensure you have complete control over how you can create and manage your shortcuts. It's all based on one function, When() , which returns what the library refers to as a Whenable . What that actually means is that the library is based around chained functions, as you can see here: When('a').IsPressed().Execute(console.log); Most When chains will culminate in a call to Execute() , which returns what we refer to as a ShortcutController . Once you call Execute() , you have registered a keyboard shortcut, the properties and behaviors of which are determined by what chained methods you chose to use. To create a shortcut, you must always start with a call to When() : When(); To set which keys (and potentially modifiers like ctrl , alt , shift and meta ) will be involved in your shortcut, you can pass them as strings to either When() or Then() : When('a').IsPressed().Then('b').IsPressed(); Then() is like a stripped down version of When() that only accepts key identifiers as strings. In your shortcut chain, you can include things like: event registers IsPressed() IsReleased() IsHeldFor() time constraints Within() Seconds() Milliseconds() focus constraints IsFocused() mode constraints ModeIs() all of which are explained in detail on their own pages. Once you call Execute() , you will receive a ShortcutController , which looks like this: const shortcut = When('a').IsPressed().Then('b').IsPressed().Execute(console.log); // shortcut controller: { // these are typically used after the shortcut has been created and the controller has been stored remove(), // unregisters the shortcut permanently pause(), // deactivates the shortcut temporarily unpause(), // activates a paused shortcut toggle(), // toggles between a paused and unpaused state trigger(), // runs the shortcut's handler programatically // these are typically used as part of the initial chain to create the shortcut Once(), // only allows the shortcut to be handled once InInput(), // allows the shortcut to be triggered when an input/textarea/select element is active AllowDefault(), // allows the default browser behavior to execute for the shortcut (prevents event.preventDefault() from running) } As you can see above, the controllers include some extra methods that are uppercase, which we call qualifiers . They control when and how the shortcut should behave, overriding some default behavior. These are meant to be used as part of a shortcut chain, but technically can be used from the controller after initialization as well: // the suggested way to use qualifiers const shortcutA = When('a').IsPressed().Execute(console.log).Once(); // technically still works, but is not recommended const shortcutB = When('b').IsPressed().Execute(console.log); shortcutB.Once(); Using shortcut controllers is one of the ways When gives you fine grained control over how and when your keyboard shortcuts are triggered. For even more control, check out groups , modes and focus .","title":"Shortcuts"},{"location":"features/shortcuts/#shortcuts","text":"When is a keyboard shortcut library, and it goes to many lengths to ensure you have complete control over how you can create and manage your shortcuts. It's all based on one function, When() , which returns what the library refers to as a Whenable . What that actually means is that the library is based around chained functions, as you can see here: When('a').IsPressed().Execute(console.log); Most When chains will culminate in a call to Execute() , which returns what we refer to as a ShortcutController . Once you call Execute() , you have registered a keyboard shortcut, the properties and behaviors of which are determined by what chained methods you chose to use. To create a shortcut, you must always start with a call to When() : When(); To set which keys (and potentially modifiers like ctrl , alt , shift and meta ) will be involved in your shortcut, you can pass them as strings to either When() or Then() : When('a').IsPressed().Then('b').IsPressed(); Then() is like a stripped down version of When() that only accepts key identifiers as strings. In your shortcut chain, you can include things like: event registers IsPressed() IsReleased() IsHeldFor() time constraints Within() Seconds() Milliseconds() focus constraints IsFocused() mode constraints ModeIs() all of which are explained in detail on their own pages. Once you call Execute() , you will receive a ShortcutController , which looks like this: const shortcut = When('a').IsPressed().Then('b').IsPressed().Execute(console.log); // shortcut controller: { // these are typically used after the shortcut has been created and the controller has been stored remove(), // unregisters the shortcut permanently pause(), // deactivates the shortcut temporarily unpause(), // activates a paused shortcut toggle(), // toggles between a paused and unpaused state trigger(), // runs the shortcut's handler programatically // these are typically used as part of the initial chain to create the shortcut Once(), // only allows the shortcut to be handled once InInput(), // allows the shortcut to be triggered when an input/textarea/select element is active AllowDefault(), // allows the default browser behavior to execute for the shortcut (prevents event.preventDefault() from running) } As you can see above, the controllers include some extra methods that are uppercase, which we call qualifiers . They control when and how the shortcut should behave, overriding some default behavior. These are meant to be used as part of a shortcut chain, but technically can be used from the controller after initialization as well: // the suggested way to use qualifiers const shortcutA = When('a').IsPressed().Execute(console.log).Once(); // technically still works, but is not recommended const shortcutB = When('b').IsPressed().Execute(console.log); shortcutB.Once(); Using shortcut controllers is one of the ways When gives you fine grained control over how and when your keyboard shortcuts are triggered. For even more control, check out groups , modes and focus .","title":"Shortcuts"},{"location":"global-methods/clearMode/","text":"When.clearMode() args: none returns: undefined When.clearMode() is used to clear the current mode , so that any shortcuts with a mode constraint become inactive. It is the counterpart to When.setMode() . // this shortcut will be active until the mode is changed or cleared When.setMode('mode1'); When().ModeIs('mode1').Then('a').IsPressed().Execute(console.log); // this would make the shortcut inactive When.clearMode();","title":"When.clearMode()"},{"location":"global-methods/clearMode/#whenclearmode","text":"args: none returns: undefined When.clearMode() is used to clear the current mode , so that any shortcuts with a mode constraint become inactive. It is the counterpart to When.setMode() . // this shortcut will be active until the mode is changed or cleared When.setMode('mode1'); When().ModeIs('mode1').Then('a').IsPressed().Execute(console.log); // this would make the shortcut inactive When.clearMode();","title":"When.clearMode()"},{"location":"global-methods/documentation/","text":"When.documentation() args: none returns: Array of Object that look like { combination: String, command: String, mode: String } When.documentation() generates objects that can be used to document the keyboard shortcuts in your app. NOTE : This method is meant to be used for development purposes, such as to assist in creating shortcut documentation, and not for use in your app itself. It only documents keyboard shortcuts that are currently registered, meaning shortcuts that are created dynamically will likely not be documented. However, if you app creates all required shortcuts immediately/statically, this method could be used to display documentation in your app. When('a').IsPressed().Execute(console.log, 'console log'); // would produce: [ { combination: '\u2193a', command: 'console log', mode: '', } ] You might use this in your app like this: const tableBody = document.querySelector('tbody')[0]; When.documentation().forEach((shortcut) => { tableBody.innerHTML += `<tr> <td>${shortcut.combination}</td> <td>${shortcut.command}</td> <td>${shortcut.mode}</td> </tr>`; }) or simply call it from the DevTools in your browser for reference.","title":"When.documentation()"},{"location":"global-methods/documentation/#whendocumentation","text":"args: none returns: Array of Object that look like { combination: String, command: String, mode: String } When.documentation() generates objects that can be used to document the keyboard shortcuts in your app. NOTE : This method is meant to be used for development purposes, such as to assist in creating shortcut documentation, and not for use in your app itself. It only documents keyboard shortcuts that are currently registered, meaning shortcuts that are created dynamically will likely not be documented. However, if you app creates all required shortcuts immediately/statically, this method could be used to display documentation in your app. When('a').IsPressed().Execute(console.log, 'console log'); // would produce: [ { combination: '\u2193a', command: 'console log', mode: '', } ] You might use this in your app like this: const tableBody = document.querySelector('tbody')[0]; When.documentation().forEach((shortcut) => { tableBody.innerHTML += `<tr> <td>${shortcut.combination}</td> <td>${shortcut.command}</td> <td>${shortcut.mode}</td> </tr>`; }) or simply call it from the DevTools in your browser for reference.","title":"When.documentation()"},{"location":"global-methods/focusChanges/","text":"When.focusChanges( focusChangeHandler ) args: focusChangeHandler : Function , a function that will be called any time focus changes within your app, which will be provided two arguments, newFocusElement and previousFocusElement , both of type HTMLElement | null returns: undefined When.focusChanges() is used to register a handler function for when focus changes within your app, as discussed in the Focus section. It allows you to tie into the focus system and make visual changes to your app to reflect the new focus target if you so choose. // add/remove a CSS class that will make the focus apparent to the user When.focusChanges((newFocusEl, prevFocusEl) => { if (newFocusEl) { newFocusEl.classList.add('focused'); } if (prevFocusEl) { prevFocusEl.classList.remove('focused'); } })","title":"When.focusChanges()"},{"location":"global-methods/focusChanges/#whenfocuschangesfocuschangehandler","text":"args: focusChangeHandler : Function , a function that will be called any time focus changes within your app, which will be provided two arguments, newFocusElement and previousFocusElement , both of type HTMLElement | null returns: undefined When.focusChanges() is used to register a handler function for when focus changes within your app, as discussed in the Focus section. It allows you to tie into the focus system and make visual changes to your app to reflect the new focus target if you so choose. // add/remove a CSS class that will make the focus apparent to the user When.focusChanges((newFocusEl, prevFocusEl) => { if (newFocusEl) { newFocusEl.classList.add('focused'); } if (prevFocusEl) { prevFocusEl.classList.remove('focused'); } })","title":"When.focusChanges(focusChangeHandler)"},{"location":"global-methods/loadLayout/","text":"When.loadLayout( layoutName ) args: layoutName : String , the name of the keyboard layout to load returns: undefined When.loadLayout() is used to change When's understanding of which keys are which, according to different keyboard layout standards. It is recommended that you either auto-detect/assume the keyboard layout for your users, or give them an option to choose their layout, if you intend to support more than one layout. Supported layouts: QWERTY (with the NumPad) 'qwerty' When.loadLayout('qwerty');","title":"When.loadLayout()"},{"location":"global-methods/loadLayout/#whenloadlayoutlayoutname","text":"args: layoutName : String , the name of the keyboard layout to load returns: undefined When.loadLayout() is used to change When's understanding of which keys are which, according to different keyboard layout standards. It is recommended that you either auto-detect/assume the keyboard layout for your users, or give them an option to choose their layout, if you intend to support more than one layout. Supported layouts: QWERTY (with the NumPad) 'qwerty' When.loadLayout('qwerty');","title":"When.loadLayout(layoutName)"},{"location":"global-methods/newGroup/","text":"When.newGroup( shortcuts ) args: shortcuts : Array , an array of ShortcutControllers returns: ShortcutGroup When.newGroup() is used to create a ShortcutGroup from an array of ShortcutControllers . This allows you to control a set of shortcuts as one unit, as covered in the section on Groups . // groups can be created in two ways, as long as you're passing ShortcutControllers // create the controllers directly in the group assignment const group1 = When.newGroup([ When('a').IsPressed().Execute(console.log), When('b').IsPressed().Execute(console.log), When('c').IsPressed().Execute(console.log), ]); // store the individual controllers then create a group from them const shortcut1 = When('a').IsPressed().Execute(console.log); const shortcut2 = When('b').IsPressed().Execute(console.log); const shortcut3 = When('c').IsPressed().Execute(console.log); const group2 = When.newGroup([ shortcut1, shortcut2, shortcut3, ]);","title":"When.newGroup()"},{"location":"global-methods/newGroup/#whennewgroupshortcuts","text":"args: shortcuts : Array , an array of ShortcutControllers returns: ShortcutGroup When.newGroup() is used to create a ShortcutGroup from an array of ShortcutControllers . This allows you to control a set of shortcuts as one unit, as covered in the section on Groups . // groups can be created in two ways, as long as you're passing ShortcutControllers // create the controllers directly in the group assignment const group1 = When.newGroup([ When('a').IsPressed().Execute(console.log), When('b').IsPressed().Execute(console.log), When('c').IsPressed().Execute(console.log), ]); // store the individual controllers then create a group from them const shortcut1 = When('a').IsPressed().Execute(console.log); const shortcut2 = When('b').IsPressed().Execute(console.log); const shortcut3 = When('c').IsPressed().Execute(console.log); const group2 = When.newGroup([ shortcut1, shortcut2, shortcut3, ]);","title":"When.newGroup(shortcuts)"},{"location":"global-methods/quiet/","text":"When.quiet() args: none returns: undefined When.quiet() prevents any console warnings from appearing. It will still allow errors to show up, however. It should be used before creating any shortcuts for optimal effect. Warnings are logged when something may produce unexpected results, but will still technically run without error. When.quiet();","title":"When.quiet()"},{"location":"global-methods/quiet/#whenquiet","text":"args: none returns: undefined When.quiet() prevents any console warnings from appearing. It will still allow errors to show up, however. It should be used before creating any shortcuts for optimal effect. Warnings are logged when something may produce unexpected results, but will still technically run without error. When.quiet();","title":"When.quiet()"},{"location":"global-methods/setMode/","text":"When.setMode( modeName ) args: modeName : String , name of the mode to switch to returns: undefined When.setMode() is used to change the mode , so that any shortcuts registered with that mode constraint will become active. It is the counterpart to When.clearMode() . // this shortcut is inactive by default When().ModeIs('mode1').Then('a').IsPressed().Execute(console.log); // the shortcut is now active When.setMode('mode1');","title":"When.setMode()"},{"location":"global-methods/setMode/#whensetmodemodename","text":"args: modeName : String , name of the mode to switch to returns: undefined When.setMode() is used to change the mode , so that any shortcuts registered with that mode constraint will become active. It is the counterpart to When.clearMode() . // this shortcut is inactive by default When().ModeIs('mode1').Then('a').IsPressed().Execute(console.log); // the shortcut is now active When.setMode('mode1');","title":"When.setMode(modeName)"},{"location":"layouts/qwerty/","text":"QWERTY Layout This layout is the default layout for When , and can be explicitly loaded with : When.loadLayout('qwerty'); Modifiers Identifiers Which Notes ctrl 17 alt 18 shift 16 left_meta meta 91 right_meta 92 not many browsers support two separate meta buttons, you should use \"meta\" F Keys Identifiers Which Notes f1 112 f2 113 f3 114 f4 115 f5 116 f6 117 f7 118 f8 119 f9 120 f10 121 f11 122 f12 123 f13 124 f14 125 f15 126 f16 127 f17 128 f18 129 f19 130 Control Keys Identifiers Which Notes escape 27 scroll_lock 145 pause_break 19 context_menu 93 backspace 8 tab 9 caps_lock 20 space 32 enter 13 insert 45 home 36 page_up 33 delete 46 end 35 page_down 34 Arrow Keys Identifiers Which Notes arrow_up 38 arrow_right 39 arrow_down 40 arrow_left 37 Numbers Identifiers Which Notes num1 49 number row num2 50 number row num3 51 number row num4 52 number row num5 53 number row num6 54 number row num7 55 number row num8 56 number row num9 57 number row num0 48 number row num_lock 144 num pad numpad_divide 111 num pad numpad_multiply 106 num pad numpad_subtract 109 num pad clear 12 num pad numpad_add 107 num pad numpad_decimal 110 num pad numpad0 96 num pad numpad1 97 num pad numpad2 98 num pad numpad3 99 num pad numpad4 100 num pad numpad5 101 num pad numpad6 102 num pad numpad7 103 num pad numpad8 104 num pad numpad9 105 num pad Symbols Identifiers Which Notes ` ~ grave_accent tilde 192 [ { left_square_bracket left_curly_bracket 219 ] } right_square_bracket right_curly_bracket 221 \\ | backslash pipe 220 ; : colon semicolon 186 ' \" apostrophe quote 222 , < comma less_than 188 > period greater_than 190 \".\" cannot be used as it conflicts with the numpad_decimal character ? forward_slash question_mark 191 \"/\" cannot be used as it conflicts with the numpad_divide character _ hyphen underscore 189 \"-\" cannot be used as it conflicts with the numpad_subtract character = plus equals 187 \"+\" cannot be used as it conflicts with the numpad_add character Letters Identifiers Which Notes a 65 b 66 c 67 d 68 e 69 f 70 g 71 h 72 i 73 j 74 k 75 l 76 m 77 n 78 o 79 p 80 q 81 r 82 s 83 t 84 u 85 v 86 w 87 x 88 y 89 z 90","title":"QWERTY"},{"location":"layouts/qwerty/#qwerty-layout","text":"This layout is the default layout for When , and can be explicitly loaded with : When.loadLayout('qwerty');","title":"QWERTY Layout"},{"location":"layouts/qwerty/#modifiers","text":"Identifiers Which Notes ctrl 17 alt 18 shift 16 left_meta meta 91 right_meta 92 not many browsers support two separate meta buttons, you should use \"meta\"","title":"Modifiers"},{"location":"layouts/qwerty/#f-keys","text":"Identifiers Which Notes f1 112 f2 113 f3 114 f4 115 f5 116 f6 117 f7 118 f8 119 f9 120 f10 121 f11 122 f12 123 f13 124 f14 125 f15 126 f16 127 f17 128 f18 129 f19 130","title":"F Keys"},{"location":"layouts/qwerty/#control-keys","text":"Identifiers Which Notes escape 27 scroll_lock 145 pause_break 19 context_menu 93 backspace 8 tab 9 caps_lock 20 space 32 enter 13 insert 45 home 36 page_up 33 delete 46 end 35 page_down 34","title":"Control Keys"},{"location":"layouts/qwerty/#arrow-keys","text":"Identifiers Which Notes arrow_up 38 arrow_right 39 arrow_down 40 arrow_left 37","title":"Arrow Keys"},{"location":"layouts/qwerty/#numbers","text":"Identifiers Which Notes num1 49 number row num2 50 number row num3 51 number row num4 52 number row num5 53 number row num6 54 number row num7 55 number row num8 56 number row num9 57 number row num0 48 number row num_lock 144 num pad numpad_divide 111 num pad numpad_multiply 106 num pad numpad_subtract 109 num pad clear 12 num pad numpad_add 107 num pad numpad_decimal 110 num pad numpad0 96 num pad numpad1 97 num pad numpad2 98 num pad numpad3 99 num pad numpad4 100 num pad numpad5 101 num pad numpad6 102 num pad numpad7 103 num pad numpad8 104 num pad numpad9 105 num pad","title":"Numbers"},{"location":"layouts/qwerty/#symbols","text":"Identifiers Which Notes ` ~ grave_accent tilde 192 [ { left_square_bracket left_curly_bracket 219 ] } right_square_bracket right_curly_bracket 221 \\ | backslash pipe 220 ; : colon semicolon 186 ' \" apostrophe quote 222 , < comma less_than 188 > period greater_than 190 \".\" cannot be used as it conflicts with the numpad_decimal character ? forward_slash question_mark 191 \"/\" cannot be used as it conflicts with the numpad_divide character _ hyphen underscore 189 \"-\" cannot be used as it conflicts with the numpad_subtract character = plus equals 187 \"+\" cannot be used as it conflicts with the numpad_add character","title":"Symbols"},{"location":"layouts/qwerty/#letters","text":"Identifiers Which Notes a 65 b 66 c 67 d 68 e 69 f 70 g 71 h 72 i 73 j 74 k 75 l 76 m 77 n 78 o 79 p 80 q 81 r 82 s 83 t 84 u 85 v 86 w 87 x 88 y 89 z 90","title":"Letters"},{"location":"types/ShortcutController/","text":"Type: ShortcutController ShortcutControllers are what Whenable .Execute() returns, and are used to control shortcuts (who'd've guessed?) after they've been created. They also contain read-only properties related to the actual shortcut. They are used as such: const controller = When('a').IsPressed().Execute(console.log); controller.toggle(); controller.pause(); controller.unpause(); controller.trigger(); controller.remove(); These controllers contain two different kinds of methods: controller methods and qualifier methods . Controller Methods Controller Methods are meant to used after the shortcut as been created and the controller stored in a variable. They include: toggle() pause() unpause() trigger() remove() toggle ShortcutController .toggle() is used to toggle the active state for a given shortcut. A shortcut that is active will be triggered any time all of its constraints are met (keys being pressed/released/held, certain elements being in focus, mode constraints, etc). An inactive shortcut cannot be triggered other than by ShortcutController .trigger() . pause ShortcutController .pause() explicitly sets a shortcut's active state to false . unpause ShortcutController .unpause() explicitly sets a shortcut's active state to true . trigger ShortcutController .trigger() programmatically executes a shortcut's handler/command. This can be used even if the shortcut's active state is false . However, the context object that is provided to handler will not receive an event property, as it normally would when triggered by a real keyboard event. remove ShortcutController .remove() permanently unregisters a shortcut so that it cannot be triggered again. This generally should be used when you are tying shortcuts to specific DOM elements, so that when the element gets removed from the DOM, the keyboard shortcut is as well. Qualifier Methods Qualifier methods are meant to be used as part of a shortcut chain, after the call to Whenable .Execute() . This is partially for semantic reasons, but also because they modify the entire shortcut, rather than just a portion of it. They include: AllowDefault() InInput() Once() AllowDefault ShortcutController .AllowDefault() overrides When's behavior of calling Event.preventDefault() . Most of the time you won't want to use this, but if you have a specific reason for wanting to allow default browser behavior for a conflicting shortcut, this is how you'd do it. // this shortcut would trigger both its handler and the default browser behavior of // opening a \"save\" prompt for the page When('ctrl+s').IsPressed().Execute(console.log).AllowDefault(); // this shortcut would follow When's default behavior of calling KeyboardEvent.preventDefault(), // this preventing the save prompt from opening When('ctrl+s').IsPressed().Execute(console.log); InInput ShortcutController .InInput() overrides When's default behavior which prevents the user from triggering shortcuts while in an input element, such as a input , textarea or select . // this shortcut would trigger even if the user was trying to type the letter \"a\" in a textarea When('a').IsPressed().Execute(console.log).InInput(); // this shortcut will only trigger if the user is not trying to type/use a select dropdown When('a').IsPressed().Execute(console.log); Once ShortcutController .Once() limits the shortcut to only being triggered one time, then it is permanently removed. This is similar to the native { once: true } option that can be provided to native event handlers, but is implemented in a different way. // this shortcut is removed after the first time it is triggered When('a').IsPressed().Execute(console.log).Once(); // this shortcut triggers any time its constraints are met and it is active When('a').IsPressed().Execute(console.log);","title":"ShortcutController"},{"location":"types/ShortcutController/#type-shortcutcontroller","text":"ShortcutControllers are what Whenable .Execute() returns, and are used to control shortcuts (who'd've guessed?) after they've been created. They also contain read-only properties related to the actual shortcut. They are used as such: const controller = When('a').IsPressed().Execute(console.log); controller.toggle(); controller.pause(); controller.unpause(); controller.trigger(); controller.remove(); These controllers contain two different kinds of methods: controller methods and qualifier methods .","title":"Type: ShortcutController"},{"location":"types/ShortcutController/#controller-methods","text":"Controller Methods are meant to used after the shortcut as been created and the controller stored in a variable. They include: toggle() pause() unpause() trigger() remove()","title":"Controller Methods"},{"location":"types/ShortcutController/#toggle","text":"ShortcutController .toggle() is used to toggle the active state for a given shortcut. A shortcut that is active will be triggered any time all of its constraints are met (keys being pressed/released/held, certain elements being in focus, mode constraints, etc). An inactive shortcut cannot be triggered other than by ShortcutController .trigger() .","title":"toggle"},{"location":"types/ShortcutController/#pause","text":"ShortcutController .pause() explicitly sets a shortcut's active state to false .","title":"pause"},{"location":"types/ShortcutController/#unpause","text":"ShortcutController .unpause() explicitly sets a shortcut's active state to true .","title":"unpause"},{"location":"types/ShortcutController/#trigger","text":"ShortcutController .trigger() programmatically executes a shortcut's handler/command. This can be used even if the shortcut's active state is false . However, the context object that is provided to handler will not receive an event property, as it normally would when triggered by a real keyboard event.","title":"trigger"},{"location":"types/ShortcutController/#remove","text":"ShortcutController .remove() permanently unregisters a shortcut so that it cannot be triggered again. This generally should be used when you are tying shortcuts to specific DOM elements, so that when the element gets removed from the DOM, the keyboard shortcut is as well.","title":"remove"},{"location":"types/ShortcutController/#qualifier-methods","text":"Qualifier methods are meant to be used as part of a shortcut chain, after the call to Whenable .Execute() . This is partially for semantic reasons, but also because they modify the entire shortcut, rather than just a portion of it. They include: AllowDefault() InInput() Once()","title":"Qualifier Methods"},{"location":"types/ShortcutController/#allowdefault","text":"ShortcutController .AllowDefault() overrides When's behavior of calling Event.preventDefault() . Most of the time you won't want to use this, but if you have a specific reason for wanting to allow default browser behavior for a conflicting shortcut, this is how you'd do it. // this shortcut would trigger both its handler and the default browser behavior of // opening a \"save\" prompt for the page When('ctrl+s').IsPressed().Execute(console.log).AllowDefault(); // this shortcut would follow When's default behavior of calling KeyboardEvent.preventDefault(), // this preventing the save prompt from opening When('ctrl+s').IsPressed().Execute(console.log);","title":"AllowDefault"},{"location":"types/ShortcutController/#ininput","text":"ShortcutController .InInput() overrides When's default behavior which prevents the user from triggering shortcuts while in an input element, such as a input , textarea or select . // this shortcut would trigger even if the user was trying to type the letter \"a\" in a textarea When('a').IsPressed().Execute(console.log).InInput(); // this shortcut will only trigger if the user is not trying to type/use a select dropdown When('a').IsPressed().Execute(console.log);","title":"InInput"},{"location":"types/ShortcutController/#once","text":"ShortcutController .Once() limits the shortcut to only being triggered one time, then it is permanently removed. This is similar to the native { once: true } option that can be provided to native event handlers, but is implemented in a different way. // this shortcut is removed after the first time it is triggered When('a').IsPressed().Execute(console.log).Once(); // this shortcut triggers any time its constraints are met and it is active When('a').IsPressed().Execute(console.log);","title":"Once"},{"location":"types/ShortcutHandler/","text":"Type: ShortcutHandler ShortcutHandlers are functions that react to shortcuts. They are registered either through Run() in association with a command , or through Execute() as an unregistered handler. They are provided with a context object that contains multiple useful properties that allow you to make very generalized handlers: { event: KeyboardEvent, // the native browser event that triggered the shortcut // (if it was a multi-key shortcut, it's the last event in the sequence) shortcut: ShortcutController, // contains the useful shortcut.keys Array which you can use to see what // keys were involved in the shortcut that triggered the handler focusedElement: HTMLElement | null, // the currently focused element, if you are utilizing the Focus system pressDuration?: number, // the exact millisecond value of the duration of a held event, // which will differ slightly from the value it was registered with } Using the context object allows you to create generalized commands, such as this: const vowels = ['a', 'e', 'i', 'o', 'u']; When('log_letter_type').IsExecuted().Run((context) => { const key = context.shortcut.keys[0]; if (vowels.includes(key)) { console.log('vowel'); } else { console.log('consonant'); } }); ['a', 'b', 'c', 'd'].forEach((letter) => { When(letter).IsPressed().Execute('log_letter_type'); });","title":"ShortcutHandler"},{"location":"types/ShortcutHandler/#type-shortcuthandler","text":"ShortcutHandlers are functions that react to shortcuts. They are registered either through Run() in association with a command , or through Execute() as an unregistered handler. They are provided with a context object that contains multiple useful properties that allow you to make very generalized handlers: { event: KeyboardEvent, // the native browser event that triggered the shortcut // (if it was a multi-key shortcut, it's the last event in the sequence) shortcut: ShortcutController, // contains the useful shortcut.keys Array which you can use to see what // keys were involved in the shortcut that triggered the handler focusedElement: HTMLElement | null, // the currently focused element, if you are utilizing the Focus system pressDuration?: number, // the exact millisecond value of the duration of a held event, // which will differ slightly from the value it was registered with } Using the context object allows you to create generalized commands, such as this: const vowels = ['a', 'e', 'i', 'o', 'u']; When('log_letter_type').IsExecuted().Run((context) => { const key = context.shortcut.keys[0]; if (vowels.includes(key)) { console.log('vowel'); } else { console.log('consonant'); } }); ['a', 'b', 'c', 'd'].forEach((letter) => { When(letter).IsPressed().Execute('log_letter_type'); });","title":"Type: ShortcutHandler"},{"location":"types/Whenable/","text":"Type: Whenable A Whenable is what When calls an object that returns itself after executing a method on it. This allows for chaining . The When() function returns a Whenable when called and allows you to start calling each of its methods in a chain, ultimately to register a shortcut and create a ShortcutController with Execute() or register a command with Run() . A Whenable contains the following methods, documented on separate pages: Then() ModeIs() IsFocused() IsInput() IsPressed() IsReleased() IsHeldFor() Within() Milliseconds() Seconds() IsExecuted() Run() Execute()","title":"Whenable"},{"location":"types/Whenable/#type-whenable","text":"A Whenable is what When calls an object that returns itself after executing a method on it. This allows for chaining . The When() function returns a Whenable when called and allows you to start calling each of its methods in a chain, ultimately to register a shortcut and create a ShortcutController with Execute() or register a command with Run() . A Whenable contains the following methods, documented on separate pages: Then() ModeIs() IsFocused() IsInput() IsPressed() IsReleased() IsHeldFor() Within() Milliseconds() Seconds() IsExecuted() Run() Execute()","title":"Type: Whenable"},{"location":"whenable-methods/Execute/","text":"Whenable .Execute( handler | commandName [, docName ]) args: handler : ShortcutHandler or commandName : String , the name of a command registered via Run() docName : optional String , the name that will show up as the command in When.documentation() Execute() defines which ShortcutHandler should be used for the shortcut, either by specifying one explicitly or providng a command name for a previously registered handler. When('some_command').IsExecuted().Run((context) => { console.log(context); }); // in When.documentation(), this shortcut will have a \"command\" property value of 'some_command' When('a').IsPressed().Execute('some_command'); // in When.documentation(), this shortcut will have a \"command\" property value of '' When('b').IsPressed().Execute(console.log); // in When.documentation(), this shortcut will have a \"command\" property value of 'log', // even though 'log' is not a registered command name When('c').IsPressed().Execute(console.log, 'log');","title":"Execute()"},{"location":"whenable-methods/Execute/#whenableexecutehandler-commandname-docname","text":"args: handler : ShortcutHandler or commandName : String , the name of a command registered via Run() docName : optional String , the name that will show up as the command in When.documentation() Execute() defines which ShortcutHandler should be used for the shortcut, either by specifying one explicitly or providng a command name for a previously registered handler. When('some_command').IsExecuted().Run((context) => { console.log(context); }); // in When.documentation(), this shortcut will have a \"command\" property value of 'some_command' When('a').IsPressed().Execute('some_command'); // in When.documentation(), this shortcut will have a \"command\" property value of '' When('b').IsPressed().Execute(console.log); // in When.documentation(), this shortcut will have a \"command\" property value of 'log', // even though 'log' is not a registered command name When('c').IsPressed().Execute(console.log, 'log');","title":"Whenable.Execute(handler | commandName[, docName])"},{"location":"whenable-methods/IsExecuted/","text":"Whenable .IsExecuted() args: none returns: Whenable IsExecuted() is used to specify that the identifier passed to When() is a command name, not a key identifier (see Commands for more details). It is used in conjunction with Run() to associate a command name with a shortcut handler. // this registers a shorcut handler with the name \"some_command\" When('some_command').IsExecuted().Run((context) => { console.log(context); }); // this sets up a shortcut that triggers the command When('a').IsPressed().Execute('some_command');","title":"IsExecuted()"},{"location":"whenable-methods/IsExecuted/#whenableisexecuted","text":"args: none returns: Whenable IsExecuted() is used to specify that the identifier passed to When() is a command name, not a key identifier (see Commands for more details). It is used in conjunction with Run() to associate a command name with a shortcut handler. // this registers a shorcut handler with the name \"some_command\" When('some_command').IsExecuted().Run((context) => { console.log(context); }); // this sets up a shortcut that triggers the command When('a').IsPressed().Execute('some_command');","title":"Whenable.IsExecuted()"},{"location":"whenable-methods/IsFocused/","text":"Whenable .IsFocused() args: none returns: Whenable IsFocused() registers the focus target provided to When() as a focus constraint on a shortcut. That target must be focused in order for the shortcut to fire. // creates a shortcut for pressing \"a\" then will only fire if an element with id \"some-id\" is focused When('id:some-id').IsFocused().Then('a').IsPressed().Execute(console.log);","title":"IsFocused()"},{"location":"whenable-methods/IsFocused/#whenableisfocused","text":"args: none returns: Whenable IsFocused() registers the focus target provided to When() as a focus constraint on a shortcut. That target must be focused in order for the shortcut to fire. // creates a shortcut for pressing \"a\" then will only fire if an element with id \"some-id\" is focused When('id:some-id').IsFocused().Then('a').IsPressed().Execute(console.log);","title":"Whenable.IsFocused()"},{"location":"whenable-methods/IsHeldFor/","text":"Whenable .IsHeldFor( n ) args: n : Number , meant to represent either a seconds or milliseconds value returns: Whenable IsHeldFor() is used in conjunction with Seconds() and Milliseconds() to register a held event for the most recent identifier in a When chain. // registers a \"held\" event for the \"a\" key that triggers after \"a\" is held for 1 second When('a').IsHeldFor(1).Seconds().Execute(console.log);","title":"IsHeldFor()"},{"location":"whenable-methods/IsHeldFor/#whenableisheldforn","text":"args: n : Number , meant to represent either a seconds or milliseconds value returns: Whenable IsHeldFor() is used in conjunction with Seconds() and Milliseconds() to register a held event for the most recent identifier in a When chain. // registers a \"held\" event for the \"a\" key that triggers after \"a\" is held for 1 second When('a').IsHeldFor(1).Seconds().Execute(console.log);","title":"Whenable.IsHeldFor(n)"},{"location":"whenable-methods/IsInput/","text":"Whenable .IsInput() args: none returns: Whenable IsInput() is used to register one or more pressed events for the most recent identifier sequence in a When chain. It allows you to create simple multi key shortcuts without having to create a long chain. The string identifier you provide must have valid key identifiers separated by spaces, with an optional time constraint at the end in penthesis in the form of ([Number]s) or ([Number]ms) // creates a shortcut that registers three pressed events for keys \"a\", \"b\" and \"c\" // to be pressed in sequence within 1 second When('a b c (1s)').IsInput().Execute(console.log); // this is the equivalent \"long\" way to achieve the same thing When('a').IsPressed() .Then('b').IsPressed() .Then('c').IsPressed() .Within(1).Seconds() .Execute(console.log);","title":"IsInput()"},{"location":"whenable-methods/IsInput/#whenableisinput","text":"args: none returns: Whenable IsInput() is used to register one or more pressed events for the most recent identifier sequence in a When chain. It allows you to create simple multi key shortcuts without having to create a long chain. The string identifier you provide must have valid key identifiers separated by spaces, with an optional time constraint at the end in penthesis in the form of ([Number]s) or ([Number]ms) // creates a shortcut that registers three pressed events for keys \"a\", \"b\" and \"c\" // to be pressed in sequence within 1 second When('a b c (1s)').IsInput().Execute(console.log); // this is the equivalent \"long\" way to achieve the same thing When('a').IsPressed() .Then('b').IsPressed() .Then('c').IsPressed() .Within(1).Seconds() .Execute(console.log);","title":"Whenable.IsInput()"},{"location":"whenable-methods/IsPressed/","text":"Whenable .IsPressed() args: none returns: Whenable IsPressed() is used to register a pressed event for the most recent identifier in a When chain. // registers a \"pressed\" event for the \"a\" key When('a').IsPressed().Execute(console.log);","title":"IsPressed()"},{"location":"whenable-methods/IsPressed/#whenableispressed","text":"args: none returns: Whenable IsPressed() is used to register a pressed event for the most recent identifier in a When chain. // registers a \"pressed\" event for the \"a\" key When('a').IsPressed().Execute(console.log);","title":"Whenable.IsPressed()"},{"location":"whenable-methods/IsReleased/","text":"Whenable .IsReleased() args: none returns: Whenable IsReleased() is used to register a released event for the most recent identifier in a When chain. // registers a \"released\" event for the \"a\" key When('a').IsReleased().Execute(console.log);","title":"IsReleased()"},{"location":"whenable-methods/IsReleased/#whenableisreleased","text":"args: none returns: Whenable IsReleased() is used to register a released event for the most recent identifier in a When chain. // registers a \"released\" event for the \"a\" key When('a').IsReleased().Execute(console.log);","title":"Whenable.IsReleased()"},{"location":"whenable-methods/ModeIs/","text":"Whenable .ModeIs( modeName ) args: modeName : String , name of the mode for the constraint returns: whenable ModeIs() is the method through which you apply a mode constraint. A shortcut with this constraint will only trigger if the mode specified matches the current mode at the time the event is fired. // creates a shortcut for pressing \"a\" while the mode is \"mode1\" When().ModeIs('mode1').Then('a').IsPressed().Execute(console.log);","title":"ModeIs()"},{"location":"whenable-methods/ModeIs/#whenablemodeismodename","text":"args: modeName : String , name of the mode for the constraint returns: whenable ModeIs() is the method through which you apply a mode constraint. A shortcut with this constraint will only trigger if the mode specified matches the current mode at the time the event is fired. // creates a shortcut for pressing \"a\" while the mode is \"mode1\" When().ModeIs('mode1').Then('a').IsPressed().Execute(console.log);","title":"Whenable.ModeIs(modeName)"},{"location":"whenable-methods/Run/","text":"Whenable .Run( handler ) args: handler : ShortcutHandler , the function to run when the command name is used in a shortcut returns: none Run() is used in conjunction with IsExecuted() to register a handler function associated with a command (see Commands for more details). // this registers a shorcut handler with the name \"some_command\" When('some_command').IsExecuted().Run((context) => { console.log(context); }); // this sets up a shortcut that triggers the command When('a').IsPressed().Execute('some_command');","title":"Run()"},{"location":"whenable-methods/Run/#whenablerunhandler","text":"args: handler : ShortcutHandler , the function to run when the command name is used in a shortcut returns: none Run() is used in conjunction with IsExecuted() to register a handler function associated with a command (see Commands for more details). // this registers a shorcut handler with the name \"some_command\" When('some_command').IsExecuted().Run((context) => { console.log(context); }); // this sets up a shortcut that triggers the command When('a').IsPressed().Execute('some_command');","title":"Whenable.Run(handler)"},{"location":"whenable-methods/SecondsMilliseconds/","text":"Whenable .Milliseconds() / Whenable .Seconds() args: none returns: Whenable Milliseconds() and Seconds() are used to either apply a time constraint (in conjunction with Within() ) or add a held event (in conjunction with IsHeldFor() ) to a shortcut chain, using the Number passed to Within()/IsHeldFor() as the quantity of time. // creates a shortcut for the \"a\" key being held for 500 milliseconds When('a').IsHeldFor(500).Milliseconds().Execute(console.log); // creates a shortcut for the \"b\" key being held for 1000 milliseconds When('b').IsHeldFor(1).Seconds().Execute(console.log);","title":"Milliseconds() / Seconds()"},{"location":"whenable-methods/SecondsMilliseconds/#whenablemilliseconds-whenableseconds","text":"args: none returns: Whenable Milliseconds() and Seconds() are used to either apply a time constraint (in conjunction with Within() ) or add a held event (in conjunction with IsHeldFor() ) to a shortcut chain, using the Number passed to Within()/IsHeldFor() as the quantity of time. // creates a shortcut for the \"a\" key being held for 500 milliseconds When('a').IsHeldFor(500).Milliseconds().Execute(console.log); // creates a shortcut for the \"b\" key being held for 1000 milliseconds When('b').IsHeldFor(1).Seconds().Execute(console.log);","title":"Whenable.Milliseconds() / Whenable.Seconds()"},{"location":"whenable-methods/Then/","text":"Whenable .Then( identifier ) args: identifier : String , a key identifier (or sequence of key identifiers, see IsInput() ) returns: Whenable Then() is a stripped down version of When() that only accepts the identifier argument. It's used to register a subsequent event in a Whenable chain for multi-key shortcuts, and for specifying the initial identifier after a call to Whenable .ModeIs() or Whenable .IsFocused() . // creates a shortcut for pressing \"a\" then \"b\" consecutively with no time constraint When('a').IsPressed().Then('b').IsPressed().Execute(console.log); // create a shortcut with a focus constaint for pressing \"a\" When('id:some-id').IsFocused().Then('a').IsPressed().Execute(console.log); // create a shortcut with a mode constaint for pressing \"a\" When().ModeIs('mode1').Then('a').IsPressed().Execute(console.log);","title":"Then()"},{"location":"whenable-methods/Then/#whenablethenidentifier","text":"args: identifier : String , a key identifier (or sequence of key identifiers, see IsInput() ) returns: Whenable Then() is a stripped down version of When() that only accepts the identifier argument. It's used to register a subsequent event in a Whenable chain for multi-key shortcuts, and for specifying the initial identifier after a call to Whenable .ModeIs() or Whenable .IsFocused() . // creates a shortcut for pressing \"a\" then \"b\" consecutively with no time constraint When('a').IsPressed().Then('b').IsPressed().Execute(console.log); // create a shortcut with a focus constaint for pressing \"a\" When('id:some-id').IsFocused().Then('a').IsPressed().Execute(console.log); // create a shortcut with a mode constaint for pressing \"a\" When().ModeIs('mode1').Then('a').IsPressed().Execute(console.log);","title":"Whenable.Then(identifier)"},{"location":"whenable-methods/When/","text":"When() args: identifier / focusTarget / commandName / undefined : String / HTMLElement , this argument can mean a few different things depending on what methods are called next on the Whenable that When() returns: identifier : a String key identifier used to register one or more keyboard events with IsPressed() , IsReleased() , IsHeldFor() or IsInput() focusTarget : either a String id: / class: target string, or an HTMLElement focus target commandName : a String command name used for registering a command undefined : When() may not be passed an argument, for example when using modes returns: Whenable When() is the starting point for everything you will do in When . Use In Shortcut Chains Used as a function (with () ), it returns a Whenable that can be used to create a keyboard shortcut: // here, the argument is an \"identifier\" used to register a \"pressed\" event When('a').IsPressed().Execute(console.log); // here, the argument is a \"focusTarget\" used to apply a \"focus\" constarint on the shortcut const el = document.getElementById('some-id'); When(el).IsFocused().Then('a').IsPressed().Execute(console.log); // here, the argument is a \"command\" name, used to register a command When('some_command').IsExecuted().Run(console.log); // here, the argument is undefined, in order to use a \"mode\" constraint on the shortcut When().ModeIs('mode1').Then('a').IsPressed().Execute(console.log); Methods When() also has its own methods that can be accessed to do global actions: When.setMode() When.clearMode() When.newGroup() When.quiet() When.loadLayout() When.focusChanges() When.documentation()","title":"When()"},{"location":"whenable-methods/When/#when","text":"args: identifier / focusTarget / commandName / undefined : String / HTMLElement , this argument can mean a few different things depending on what methods are called next on the Whenable that When() returns: identifier : a String key identifier used to register one or more keyboard events with IsPressed() , IsReleased() , IsHeldFor() or IsInput() focusTarget : either a String id: / class: target string, or an HTMLElement focus target commandName : a String command name used for registering a command undefined : When() may not be passed an argument, for example when using modes returns: Whenable When() is the starting point for everything you will do in When .","title":"When()"},{"location":"whenable-methods/When/#use-in-shortcut-chains","text":"Used as a function (with () ), it returns a Whenable that can be used to create a keyboard shortcut: // here, the argument is an \"identifier\" used to register a \"pressed\" event When('a').IsPressed().Execute(console.log); // here, the argument is a \"focusTarget\" used to apply a \"focus\" constarint on the shortcut const el = document.getElementById('some-id'); When(el).IsFocused().Then('a').IsPressed().Execute(console.log); // here, the argument is a \"command\" name, used to register a command When('some_command').IsExecuted().Run(console.log); // here, the argument is undefined, in order to use a \"mode\" constraint on the shortcut When().ModeIs('mode1').Then('a').IsPressed().Execute(console.log);","title":"Use In Shortcut Chains"},{"location":"whenable-methods/When/#methods","text":"When() also has its own methods that can be accessed to do global actions: When.setMode() When.clearMode() When.newGroup() When.quiet() When.loadLayout() When.focusChanges() When.documentation()","title":"Methods"},{"location":"whenable-methods/Within/","text":"Whenable .Within( n ) args: n : Number , representing a quantity of seconds or milliseconds returns: Whenable Within() is used to place a time constraint on a sequential shortcut (one involving multiple key events). Within() should be followed by either Seconds() or Milliseconds() in order to apply the time constraint. // creates a shortcut for pressing \"a\" then \"b\" sequentially within 1 second of each other When('a').IsPressed().Then('b').IsPressed().Within(1).Seconds().Execute(console.log);","title":"Within()"},{"location":"whenable-methods/Within/#whenablewithinn","text":"args: n : Number , representing a quantity of seconds or milliseconds returns: Whenable Within() is used to place a time constraint on a sequential shortcut (one involving multiple key events). Within() should be followed by either Seconds() or Milliseconds() in order to apply the time constraint. // creates a shortcut for pressing \"a\" then \"b\" sequentially within 1 second of each other When('a').IsPressed().Then('b').IsPressed().Within(1).Seconds().Execute(console.log);","title":"Whenable.Within(n)"}]}